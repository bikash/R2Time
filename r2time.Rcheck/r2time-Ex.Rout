
R version 3.0.1 (2013-05-16) -- "Good Sport"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "r2time"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('r2time')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("pushList")
> ### * pushList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pushList
> ### Title: initilization function
> ### Aliases: pushList
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (l) 
+ {
+     lst <- get(l, parent.frame())
+     a <- c("1")
+     y <- append(eval(as.name("a")), lst)
+     assign(l, y, envir = parent.frame())
+   }
function (l) 
{
    lst <- get(l, parent.frame())
    a <- c("1")
    y <- append(eval(as.name("a")), lst)
    assign(l, y, envir = parent.frame())
}
> 
> 
> 
> cleanEx()
> nameEx("pushdata")
> ### * pushdata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pushdata
> ### Title: initilization function
> ### Aliases: pushdata
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (l, x) 
+ {
+     assign(l, append(eval(as.name(l)), x), envir = parent.frame())
+   }
function (l, x) 
{
    assign(l, append(eval(as.name(l)), x), envir = parent.frame())
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.String2Bytes")
> ### * r2t.String2Bytes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.String2Bytes
> ### Title: initilization function
> ### Aliases: r2t.String2Bytes
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (rowkey) 
+ {
+     obj <- .jnew("DataType")
+     res <- .jcall(obj, "[B", "String2Bytes", rowkey)
+   }
function (rowkey) 
{
    obj <- .jnew("DataType")
    res <- .jcall(obj, "[B", "String2Bytes", rowkey)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.byte2long")
> ### * r2t.byte2long
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.byte2long
> ### Title: initilization function
> ### Aliases: r2t.byte2long
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (ra, data) 
+ {
+     res <- .jcall(ra, "J", "byte2long", data)
+   }
function (ra, data) 
{
    res <- .jcall(ra, "J", "byte2long", data)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.bytes2float")
> ### * r2t.bytes2float
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.bytes2float
> ### Title: initilization function
> ### Aliases: r2t.bytes2float
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (value) 
+ {
+     obj <- .jnew("org.apache.hadoop.hbase.util.Bytes")
+     res <- .jcall(obj, "F", "toFloat", value)
+   }
function (value) 
{
    obj <- .jnew("org.apache.hadoop.hbase.util.Bytes")
    res <- .jcall(obj, "F", "toFloat", value)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.bytes2float_1")
> ### * r2t.bytes2float_1
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.Bytes2Float
> ### Title: initilization function
> ### Aliases: r2t.Bytes2Float
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (data) 
+ {
+     obj <- .jnew("DataType")
+     res <- .jcall(obj, "F", "Bytes2Float", data)
+   }
function (data) 
{
    obj <- .jnew("DataType")
    res <- .jcall(obj, "F", "Bytes2Float", data)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.connect")
> ### * r2t.connect
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.connect
> ### Title: initilization function
> ### Aliases: r2t.connect
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (ra, tablename) 
+ {
+     tb <- .jnew("org/apache/hadoop/hbase/client/HTable", tablename)
+     j <- function(ra, tb) {
+         return(list(getTagK = function() getTagK(ra = ra, tb = tb), 
+             getTagV = function() getTagV(ra = ra, tb = tb), table = tb))
+     }
+     return(j(ra, tb))
+   }
function (ra, tablename) 
{
    tb <- .jnew("org/apache/hadoop/hbase/client/HTable", tablename)
    j <- function(ra, tb) {
        return(list(getTagK = function() getTagK(ra = ra, tb = tb), 
            getTagV = function() getTagV(ra = ra, tb = tb), table = tb))
    }
    return(j(ra, tb))
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.convertByteArraytoFloat")
> ### * r2t.convertByteArraytoFloat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.convertByteArraytoFloat
> ### Title: initilization function
> ### Aliases: r2t.convertByteArraytoFloat
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (v) 
+ {
+     obj <- .jnew("DataType")
+     res <- .jcall(obj, "[F", "convertBytetoFloat", v)
+   }
function (v) 
{
    obj <- .jnew("DataType")
    res <- .jcall(obj, "[F", "convertBytetoFloat", v)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.getBaseTimestamp")
> ### * r2t.getBaseTimestamp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.getBaseTimestamp
> ### Title: initilization function
> ### Aliases: r2t.getBaseTimestamp
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (rowkey)
+ {
+     obj <- .jnew("DataType")
+     res <- .jcall(obj, "I", "getBaseTimestamp", rowkey)
+   }
function (rowkey) 
{
    obj <- .jnew("DataType")
    res <- .jcall(obj, "I", "getBaseTimestamp", rowkey)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.getLong")
> ### * r2t.getLong
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.getLong
> ### Title: initilization function
> ### Aliases: r2t.getLong
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (ra, data, offset) 
+ {
+     res <- .jcall(ra, "J", "getLong", data, offset)
+   }
function (ra, data, offset) 
{
    res <- .jcall(ra, "J", "getLong", data, offset)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.getMetrics")
> ### * r2t.getMetrics
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.getMetrics
> ### Title: initilization function
> ### Aliases: r2t.getMetrics
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (ra, tb) 
+ {
+     res <- .jcall(ra, "[B", "getMetrics", tb)
+   }
function (ra, tb) 
{
    res <- .jcall(ra, "[B", "getMetrics", tb)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.getRealTimestamp")
> ### * r2t.getRealTimestamp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.connect
> ### Title: initilization function
> ### Aliases: r2t.connect
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (ra, tablename) 
+ {
+     tb <- .jnew("org/apache/hadoop/hbase/client/HTable", tablename)
+     j <- function(ra, tb) {
+         return(list(getTagK = function() getTagK(ra = ra, tb = tb), 
+             getTagV = function() getTagV(ra = ra, tb = tb), table = tb))
+     }
+     return(j(ra, tb))
+   }
function (ra, tablename) 
{
    tb <- .jnew("org/apache/hadoop/hbase/client/HTable", tablename)
    j <- function(ra, tb) {
        return(list(getTagK = function() getTagK(ra = ra, tb = tb), 
            getTagV = function() getTagV(ra = ra, tb = tb), table = tb))
    }
    return(j(ra, tb))
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.getRowBaseTimestamp")
> ### * r2t.getRowBaseTimestamp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.getRowKey
> ### Title: initilization function
> ### Aliases: r2t.getRowKey
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (sdate, edate, tagk, tagv, metrics)
+ {
+     obj <- .jnew("DataType")
+     res <- .jcall(obj, "[J", "getRowKey", sdate, edate, tagk,
+         tagv, metrics)
+   }
function (sdate, edate, tagk, tagv, metrics) 
{
    obj <- .jnew("DataType")
    res <- .jcall(obj, "[J", "getRowKey", sdate, edate, tagk, 
        tagv, metrics)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.getRowKey")
> ### * r2t.getRowKey
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.getRowKey
> ### Title: initilization function
> ### Aliases: r2t.getRowKey
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (sdate, edate, tagk, tagv, metrics) 
+ {
+     obj <- .jnew("DataType")
+     res <- .jcall(obj, "[J", "getRowKey", sdate, edate, tagk, 
+         tagv, metrics)
+   }
function (sdate, edate, tagk, tagv, metrics) 
{
    obj <- .jnew("DataType")
    res <- .jcall(obj, "[J", "getRowKey", sdate, edate, tagk, 
        tagv, metrics)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.getRowkeyFilter")
> ### * r2t.getRowkeyFilter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.getRowkeyFilter
> ### Title: initilization function
> ### Aliases: r2t.getRowkeyFilter
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (sdate, edate, metrics, tagk, tagv) 
+ {
+     tagk = pushList("tagk")
+     if (!is.array(tagk)) 
+         tagkey = array(data = tagk, dim = length(tagk))
+     else tagkey = tagk
+     tagv = pushList("tagv")
+     if (!is.array(tagv)) 
+         tagvalue = array(data = tagv, dim = length(tagv))
+     else tagvalue = tagv
+     obj <- .jnew("DataType")
+     res <- .jcall(obj, "[S", "getRowkeyFilter", sdate, edate, 
+         metrics, tagkey, tagvalue)
+   }
function (sdate, edate, metrics, tagk, tagv) 
{
    tagk = pushList("tagk")
    if (!is.array(tagk)) 
        tagkey = array(data = tagk, dim = length(tagk))
    else tagkey = tagk
    tagv = pushList("tagv")
    if (!is.array(tagv)) 
        tagvalue = array(data = tagv, dim = length(tagv))
    else tagvalue = tagv
    obj <- .jnew("DataType")
    res <- .jcall(obj, "[S", "getRowkeyFilter", sdate, edate, 
        metrics, tagkey, tagvalue)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.getTagKeys")
> ### * r2t.getTagKeys
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.getTagKeys
> ### Title: initilization function
> ### Aliases: r2t.getTagKeys
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (ra, tb) 
+ {
+     res <- .jcall(ra, "[B", "getTagK", tb)
+   }
function (ra, tb) 
{
    res <- .jcall(ra, "[B", "getTagK", tb)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.getTagValue")
> ### * r2t.getTagValue
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.getTagValue
> ### Title: initilization function
> ### Aliases: r2t.getTagValue
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (ra, tb, tag) 
+ {
+     res <- .jcall(ra, "[B", "getTagv", tb)
+   }
function (ra, tb, tag) 
{
    res <- .jcall(ra, "[B", "getTagv", tb)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.getTimeSereiesData")
> ### * r2t.getTimeSereiesData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.getTimeSereiesData
> ### Title: initilization function
> ### Aliases: r2t.getTimeSereiesData
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (sdate, edate, tagk, tagv, metrics) 
+ {
+     obj <- .jnew("DataType")
+     res <- .jcall(obj, "[[J", "getTimeSereiesData", sdate, edate, 
+         tagk, tagv, metrics)
+   }
function (sdate, edate, tagk, tagv, metrics) 
{
    obj <- .jnew("DataType")
    res <- .jcall(obj, "[[J", "getTimeSereiesData", sdate, edate, 
        tagk, tagv, metrics)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.hbaseinput")
> ### * r2t.hbaseinput
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.hbaseinput
> ### Title: initilization function
> ### Aliases: r2t.hbaseinput
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (table, colspec = NULL, rows = NULL, caching = 1000, 
+     cacheBlocks = FALSE, autoReduceDetect = FALSE, jars = "", 
+     zooinfo, filter = "", batch = 1L, fulltable = 0) 
+ {
+     makeRaw <- function(a) {
+         J("org.apache.commons.codec.binary.Base64")$encodeBase64String(.jbyte(a))
+     }
+     table <- eval(table)
+     colspec <- eval(colspec)
+     rows <- eval(rows)
+     cacheBlocks <- eval(cacheBlocks)
+     autoReduceDetect <- eval(autoReduceDetect)
+     caching <- eval(caching)
+     function(mapred, direction, callers) {
+         if (is.null(table)) 
+             stop("Please provide table type e.g. tsdb")
+         mapred$rhipe.hbase.tablename <- as.character(table[1])
+         mapred$rhipe.hbase.colspec <- NULL
+         if (!is.null(rows)) {
+             mapred$rhipe.hbase.rowlim.start <- rows[[1]]
+             mapred$rhipe.hbase.rowlim.end <- rows[[2]]
+         }
+         mapred$rhipe.hbase.filter <- filter
+         mapred$rhipe.hbase.set.batch <- batch
+         mapred$parse.ifolder = ""
+         mapred$rhipe.hbase.mozilla.cacheblocks <- sprintf("%s:%s", 
+             as.integer(caching), as.integer(cacheBlocks))
+         mapred$zookeeper.znode.parent <- zooinfo$zookeeper.znode.parent
+         mapred$hbase.zookeeper.quorum <- zooinfo$hbase.zookeeper.quorum
+         message(sprintf("Using %s table", table))
+         mapred$rhipe.hbase.dateformat <- "yyyyMMdd"
+         mapred$rhipe.hbase.mozilla.prefix <- "byteprefix"
+         mapred$rhipe_inputformat_class <- "RHScanTable"
+         mapred$rhipe_inputformat_keyclass <- "org.godhuli.rhipe.RHBytesWritable"
+         mapred$rhipe_inputformat_valueclass <- "RHResult"
+         mapred$jarfiles <- jars
+         mapred
+     }
+   }
function (table, colspec = NULL, rows = NULL, caching = 1000, 
    cacheBlocks = FALSE, autoReduceDetect = FALSE, jars = "", 
    zooinfo, filter = "", batch = 1L, fulltable = 0) 
{
    makeRaw <- function(a) {
        J("org.apache.commons.codec.binary.Base64")$encodeBase64String(.jbyte(a))
    }
    table <- eval(table)
    colspec <- eval(colspec)
    rows <- eval(rows)
    cacheBlocks <- eval(cacheBlocks)
    autoReduceDetect <- eval(autoReduceDetect)
    caching <- eval(caching)
    function(mapred, direction, callers) {
        if (is.null(table)) 
            stop("Please provide table type e.g. tsdb")
        mapred$rhipe.hbase.tablename <- as.character(table[1])
        mapred$rhipe.hbase.colspec <- NULL
        if (!is.null(rows)) {
            mapred$rhipe.hbase.rowlim.start <- rows[[1]]
            mapred$rhipe.hbase.rowlim.end <- rows[[2]]
        }
        mapred$rhipe.hbase.filter <- filter
        mapred$rhipe.hbase.set.batch <- batch
        mapred$parse.ifolder = ""
        mapred$rhipe.hbase.mozilla.cacheblocks <- sprintf("%s:%s", 
            as.integer(caching), as.integer(cacheBlocks))
        mapred$zookeeper.znode.parent <- zooinfo$zookeeper.znode.parent
        mapred$hbase.zookeeper.quorum <- zooinfo$hbase.zookeeper.quorum
        message(sprintf("Using %s table", table))
        mapred$rhipe.hbase.dateformat <- "yyyyMMdd"
        mapred$rhipe.hbase.mozilla.prefix <- "byteprefix"
        mapred$rhipe_inputformat_class <- "RHScanTable"
        mapred$rhipe_inputformat_keyclass <- "org.godhuli.rhipe.RHBytesWritable"
        mapred$rhipe_inputformat_valueclass <- "RHResult"
        mapred$jarfiles <- jars
        mapred
    }
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.intBittoFloat")
> ### * r2t.intBittoFloat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.intBittoFloat
> ### Title: initilization function
> ### Aliases: r2t.intBittoFloat
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (i) 
+ {
+     sign <- bitAnd(i, 2147483648)
+     if (sign == 0) 
+         sign <- 1
+     else sign <- -1
+     exp <- bitShiftR(bitAnd(i, 2139095040), 23)
+     man <- bitAnd(i, 8388607)
+     man <- bitOr(man, 8388608)
+     f <- sign * man * (2^(exp - 150))
+   }
function (i) 
{
    sign <- bitAnd(i, 2147483648)
    if (sign == 0) 
        sign <- 1
    else sign <- -1
    exp <- bitShiftR(bitAnd(i, 2139095040), 23)
    man <- bitAnd(i, 8388607)
    man <- bitOr(man, 8388608)
    f <- sign * man * (2^(exp - 150))
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.long2byte")
> ### * r2t.long2byte
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.long2byte
> ### Title: initilization function
> ### Aliases: r2t.long2byte
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (ra, data) 
+ {
+     res <- .jcall(ra, "[B", "getTagK", data)
+   }
function (ra, data) 
{
    res <- .jcall(ra, "[B", "getTagK", data)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.rhwatch")
> ### * r2t.rhwatch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.rhwatch
> ### Title: initilization function
> ### Aliases: r2t.rhwatch
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (table, sdate, edate, metrics, tagk, tagv, caching = 1400L, 
+     cacheBlocks = FALSE, autoReduceDetect = FALSE, batch = 100, 
+     jars = "", zooinfo, fulltable = 0, output = "", jobname = "MapReduce job", 
+     mapred = "") 
+ {
+     r <- r2t.getRowkeyFilter(sdate, edate, metrics, tagk, tagv)
+     rows <- c(r[1], r[2])
+     filter <- r[3]
+     z <- rhwatch(map = map, reduce = reduce, input = r2t.hbaseinput(table = table, 
+         rows = rows, caching = 1400L, cacheBlocks = FALSE, jars = jars, 
+         zooinfo = zooinfo, filter = filter, batch = 100), output = output, 
+         jobname = jobname, mapred = mapred, param = list(beginningOflastMonth = Sys.Date() - 
+             45))
+   }
function (table, sdate, edate, metrics, tagk, tagv, caching = 1400L, 
    cacheBlocks = FALSE, autoReduceDetect = FALSE, batch = 100, 
    jars = "", zooinfo, fulltable = 0, output = "", jobname = "MapReduce job", 
    mapred = "") 
{
    r <- r2t.getRowkeyFilter(sdate, edate, metrics, tagk, tagv)
    rows <- c(r[1], r[2])
    filter <- r[3]
    z <- rhwatch(map = map, reduce = reduce, input = r2t.hbaseinput(table = table, 
        rows = rows, caching = 1400L, cacheBlocks = FALSE, jars = jars, 
        zooinfo = zooinfo, filter = filter, batch = 100), output = output, 
        jobname = jobname, mapred = mapred, param = list(beginningOflastMonth = Sys.Date() - 
            45))
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.setInt")
> ### * r2t.setInt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.setInt
> ### Title: initilization function
> ### Aliases: r2t.setInt
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (ra, data, n, offset) 
+ {
+     .jcall(ra, "V", "setInt", data, n, offset)
+   }
function (ra, data, n, offset) 
{
    .jcall(ra, "V", "setInt", data, n, offset)
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.toFloat")
> ### * r2t.toFloat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.toFloat
> ### Title: initilization function
> ### Aliases: r2t.toFloat
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (x) 
+ {
+     if (length(x) > 7) 
+         return(0)
+     else {
+         i <- r2t.toInt(x)
+         f <- r2t.intBittoFloat(i)
+         return(f)
+     }
+   }
function (x) 
{
    if (length(x) > 7) 
        return(0)
    else {
        i <- r2t.toInt(x)
        f <- r2t.intBittoFloat(i)
        return(f)
    }
}
> 
> 
> 
> cleanEx()
> nameEx("r2t.toInt")
> ### * r2t.toInt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: r2t.toInt
> ### Title: Conversion to int function
> ### Aliases: r2t.toInt
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> ## The function is currently defined as
> function (x) 
+ {
+     n <- 0
+     for (i in 1:length(x)) {
+         n <- bitShiftL(n, 8)
+         n <- bitXor(n, bitAnd(x[i], 255))
+     }
+     return(n)
+   }
function (x) 
{
    n <- 0
    for (i in 1:length(x)) {
        n <- bitShiftL(n, 8)
        n <- bitXor(n, bitAnd(x[i], 255))
    }
    return(n)
}
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.232 0 0.26 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
